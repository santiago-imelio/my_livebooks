# Median Filter

```elixir
Mix.install([
  {:nx, "~> 0.7.1"},
  {:kino, "~> 0.12.3"},
  {:vega_lite, "~> 0.1.9"},
  {:tucan, "~> 0.3.1"},
  {:kino_vega_lite, "~> 0.1.11"},
  {:exla, "~> 0.7.1"},
  {:req, "~> 0.4.14"}
])
```

## Introduction

In this notebook we are going to implement the [Median Filter](https://en.wikipedia.org/wiki/Median_filter). It's a digital filtering technique used to remove noise from a signal, and we will demonstrate how it works by applying this filter to a severly corrupted image.

## Load the image

```elixir
image_input = Kino.Input.image("Upload an image")
```

```elixir
%{file_ref: file_ref, height: height, width: width} = Kino.Input.read(image_input)

img_tensor =
  file_ref
  |> Kino.Input.file_path()
  |> File.read!()
  |> Nx.from_binary({:u, 8})
```

```elixir
img_tensor = Nx.reshape(img_tensor, {height, width, 3})
```

```elixir
Kino.Image.new(img_tensor)
```

## Utilities

We will implement the median filter for 2D tensors, which means we need to convert our original image into a 2D tensor. This is, keeping only one channel of the three RGB channels. So we implement a utility function to convert an RGB image into what is commonly known as grayscale.

```elixir
defmodule Image do
  import Nx.Defn

  @rgb_weights Nx.tensor([0.2125, 0.7154, 0.0721])

  @doc ~S"""
  https://github.com/scikit-image/scikit-image/blob/v0.23.2/skimage/color/colorconv.py#L942
  """
  defn to_grayscale(img) do
    Nx.dot(img, @rgb_weights)
  end

  defn(to_rgb(img), do: Nx.stack([img, img, img], axis: 2))

  def plot(img) do
    {height, width} = Nx.shape(img)
    opts = [height: height, width: width, color_scheme: :greys, reverse: true]
    Tucan.imshow(img, opts)
  end
end
```

The output is an image with the same height and width, but with the channel dimension removed.

```elixir
img = Image.to_grayscale(img_tensor)
```

```elixir
Image.plot(img)
```

```elixir
rgb_img = Image.to_rgb(img) |> Nx.as_type({:u, 8})
```

```elixir
Kino.Image.new(rgb_img)
```

<!-- livebook:{"branch_parent_index":2} -->

## Implementation

The following is an implementation of 2-dimensional median filter. The boundary strategy in this case is given by how `Nx.slice/3` handles the edges when we compute a window.

```elixir
defmodule Filters do
  def median_filter_2d(t, opts \\ [kernel_size: 3]) do
    kernel_size = Keyword.get(opts, :kernel_size)

    {height, width} = Nx.shape(t)
    window_pad_size = round((kernel_size - 1) / 2)

    for i <- 0..(height - 1) do
      for j <- 0..(width - 1) do
        y_axis_start_idx =
          if i - window_pad_size <= 0 do
            0
          else
            round(i - window_pad_size)
          end

        x_axis_start_idx =
          if j - window_pad_size <= 0 do
            0
          else
            round(j - window_pad_size)
          end

        Nx.slice(t, [y_axis_start_idx, x_axis_start_idx], [kernel_size, kernel_size])
        |> Nx.median()
        |> Nx.to_number()
      end
    end
    |> Nx.tensor()
    |> Nx.as_type({:f, 32})
  end
end
```

```elixir
img_filt_3 = Filters.median_filter_2d(img, kernel_size: 3)
```

When we show the filtered image, we see a big improvement. There is still a lot of noise on the image, although now we can see more clearly the underlying picture.

```elixir
Image.plot(img_filt_3)
```

Increasing the `kernel_size` parameter will help to reduce the noise even more. However, this will inevitably start to blur the image, given that increasing the kernel size implies computing bigger windows, hence using more neighbours to compute the median.

```elixir
img_filt_5 = Filters.median_filter_2d(img, kernel_size: 7)
Image.plot(img_filt_5)
```

Even though our implementation works fine for this image, we can increase performance by refactoring our code using `Nx.Defn` module. That will allow us to run our code using a compiler such as [EXLA](https://hexdocs.pm/exla/EXLA.html).

<!-- livebook:{"branch_parent_index":2} -->

## Optimization using Nx.Defn

TODO:

* Explanations of Nx.Defn, while loops, and backends and compilers.

```elixir
defmodule FiltersDefn do
  import Nx.Defn

  defn median_filter_2d(t, opts \\ [kernel_size: 3]) do
    kernel_size = opts[:kernel_size]
    kernel_tensor = Nx.broadcast(0.0, {kernel_size})
    {height, width} = Nx.shape(t)
    window_pad_size = Nx.round((kernel_size - 1) / 2)
    output = Nx.broadcast(0.0, Nx.shape(t))

    {_, _, _, _, _, _, result} =
      while {i = 0, t, kernel_tensor, height, width, window_pad_size, output}, i < height do
        row = Nx.broadcast(0.0, {elem(Nx.shape(t), 1)})

        {_, _, _, _, _, _, _, ith_row} =
          while {j = 0, t, i, kernel_tensor, height, width, window_pad_size, row}, j < width do
            y_axis_start_idx =
              if i - window_pad_size <= 0 do
                0
              else
                i - window_pad_size
              end
              |> Nx.as_type({:u, 32})

            x_axis_start_idx =
              if j - window_pad_size <= 0 do
                0
              else
                j - window_pad_size
              end
              |> Nx.as_type({:u, 32})

            kernel_size = elem(Nx.shape(kernel_tensor), 0)

            ij_median =
              Nx.slice(
                t,
                [y_axis_start_idx, x_axis_start_idx],
                [kernel_size, kernel_size]
              )
              |> Nx.median()
              |> Nx.broadcast({1})

            {j + 1, t, i, kernel_tensor, height, width, window_pad_size,
             Nx.put_slice(row, [j], ij_median)}
          end

        {i + 1, t, kernel_tensor, height, width, window_pad_size,
         Nx.put_slice(output, [i, 0], Nx.stack(ith_row, axis: 0))}
      end

    result
  end
end
```

```elixir
params = [img, [kernel_size: 4]]
opts = [compiler: EXLA]

filt = Nx.Defn.jit_apply(&FiltersDefn.median_filter_2d/2, params, opts)
```

```elixir
Image.plot(filt)
```
